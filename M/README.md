## M. Массив юрского периода

| Язык                    | Ограничение времени | Ограничение памяти | Ввод                           | Вывод                            |
|-------------------------|---------------------|--------------------|--------------------------------|----------------------------------|
| Все языки               | 1.2 секунды         | 256Mb              | стандартный ввод или input.txt | стандартный вывод или output.txt |
| Golang 1.14.4 + network | 0.6 секунд          | 64Mb               |                                |                                  |
| Node.js 14.15.5         | 3 секунды           | 256Mb              |                                |                                  |
| Python 3.7.3            | 3 секунды           | 256Mb              |                                |                                  |
| Golang 1.16             | 0.6 секунд          | 64Mb               |                                |                                  |
| GNU c++17 7.3           | 0.6 секунд          | 64Mb               |                                |                                  |

В этой задаче вам надо реализовать структуру данных исторический массив. Исторический массив изначально имеет размер n и
заполнен нулями. Он поддерживает следующие операции:
set(index, value) - присвоить элементу на позиции i значение value
begin_new_era(era_id) - эта операция начинает новую эру с номером era_id. В каждый момент времени активна единственная
эра. Изначальная эра имеет индекс era_id=0. Когда начинается новая эра, предыдущая заканчивается.
get(index, era_id) - получить значение элемента на позиции index на момент окончания эры era_id.

### Формат ввода

В первой строке дан размер исторического массива n(1≤n≤100000). Во второй строке дано число операций, производимых с
массивом, — q(1≤q≤100000) В следующих q строках даны операции по одной в строке. Есть три вида операций:
set index value (0≤index≤n−1,0≤value≤10^9)
begin_new_era era_id (1≤era_id≤10^9)
get index era_id (0≤index≤n−1,0≤era_id≤10^9)
Гарантируется, что при запросе значения из конкретной эры эта эра уже успела закончиться.
Гарантируется, что при создании эры с идентификатором era_id этот индентификатор еще не был использован.

### Формат вывода

На каждую операцию третьего типа необходимо вывести на отдельной строке значение, которое содержал элемент массива с
номером index на момент окончания эры era_id.

### Пример 1

| Ввод                  | Вывод |
|:----------------------|:-----:|
| 6                     |   3   | 
| 9                     |   8   |
| set 0 3               |   9   |
| set 1 8               |   3   |
| begin_new_era 6000    |       |
| get 0 0               |       |
| get 1 0               |       |
| set 0 9               |       |
| begin_new_era 1000000 |       |
| get 0 6000            |       |
| get 0 0               |       |

### Пример 2

| Ввод                 | Вывод |
|:---------------------|:-----:|
| 1                    |   2   |
| 12                   |  42   |
| set 0 1              |  100  |
| set 0 2              |       |
| begin_new_era 1000   |       |
| set 0 4              |       |
| set 0 100            |       |
| begin_new_era 666    |       |
| set 0 7              |       |
| set 0 42             |       |
| begin_new_era 424242 |       |
| get 0 0              |       |
| get 0 666            |       |
| get 0 1000           |       |
